# Best Practices и рекомендации (Неделя 3)

## 1. Общие подходы к проектированию процедур и триггеров

1. **Избегайте "процедур бога"**. Разбивайте сложную бизнес-логику на переиспользуемые модули с понятными зонами ответственности.
2. **Версионируйте объекты**. Добавляйте в заголовок процедуры или триггера номер версии, дату и автора. Введите CHANGELOG в wiki проекта.
3. **Документируйте параметры**. В комментариях описывайте ожидаемые значения, типы, единицы измерения и сценарии использования входных/выходных параметров.
4. **Явно управляйте транзакциями**. Не открывайте транзакцию внутри процедуры, если она может быть вызвана в другой транзакции, без `SAVEPOINT` и проверки `@@TRANCOUNT`.
5. **Разделяйте слои**. Храните логику в базе, но не смешивайте её с управлением правами или UI-слоем.

## 2. Производительность процедур

1. **Объявляйте параметры с правильными типами и длиной**. Несовпадение типов вызывает неявные преобразования и индексные сканы.
2. **Используйте `SET NOCOUNT ON`**. Уменьшает накладные расходы на сетевые сообщения при выполнении пакетов.
3. **Минимизируйте использование курсоров**. Заменяйте курсоры операциями set-based. Если курсор необходим, выбирайте типа `FAST_FORWARD` или `READ_ONLY`.
4. **Компилируемые подсказки** (`WITH RECOMPILE`, `OPTIMIZE FOR`) используйте осторожно. Они полезны для процедур с параметрическим сникером, но увеличивают стоимость компиляции.
5. **Планируйте статистику**. Обновляйте статистику перед критичными пакетами или используйте `sp_create_plan_guide` для стабилизации планов.
6. **Профилируйте выполнение** через `SET STATISTICS IO, TIME ON`, Extended Events или Query Store.

## 3. Обработка ошибок и логирование

1. **TRY/CATCH**. Всегда оборачивайте критичные участки в блоки `BEGIN TRY ... END TRY / BEGIN CATCH ... END CATCH`.
2. В CATCH-блоке сохраняйте `ERROR_NUMBER()`, `ERROR_MESSAGE()`, `ERROR_LINE()`, `ERROR_PROCEDURE()` в таблицу логирования.
3. Возвращайте **статус выполнения** через `RETURN` или `OUTPUT` параметры. Не полагайтесь только на исключения.
4. Для сервисных процедур используйте **идемпотентные операции** и логируйте входящие payload'ы (XML/JSON) для отладки.
5. Соблюдайте **уровни серьёзности** ошибок: для непоправимых ошибок используйте `THROW`.

## 4. Триггеры

1. **Избегайте бизнес-логики**. Триггеры предназначены для контроля целостности и аудита, а не для сложной бизнес-логики.
2. **Работайте с множеством строк**. Таблицы `inserted` и `deleted` содержат набор, а не одиночные строки. Пишите set-based код.
3. **Минимизируйте дополнительную нагрузку**. Легковесно логируйте только необходимые поля, используйте асинхронную репликацию логов (Service Broker) для тяжёлой обработки.
4. **Контролируйте рекурсию**. Устанавливайте `ALTER DATABASE CURRENT SET RECURSIVE_TRIGGERS OFF` или проверяйте `TRIGGER_NESTLEVEL()`.
5. **Документируйте порядок выполнения**. Если на таблице несколько триггеров одного типа, используйте `sp_settriggerorder`.

## 5. Расширенный T-SQL

1. **TRY/CATCH + THROW**. Для повторного выброса используйте `THROW;` без параметров внутри CATCH, чтобы сохранить стек.
2. **CASE против вложенных IF**. Выбирайте `CASE` в SELECT/ORDER BY для читаемости и производительности.
3. **Используйте табличные переменные с осторожностью**. Начиная с SQL Server 2019, они получают статистику, но всё ещё подходят для малых наборов.
4. **Динамический SQL с параметрами**. Используйте `sp_executesql` и параметризацию для предотвращения SQL-инъекций.
5. **Сочетайте временные таблицы и CTE**. Временные таблицы хороши для промежуточных результатов, CTE — для читаемости и рекурсивных задач.

## 6. XML в SQL Server

1. **Определите схему** (`XML Schema Collection`) для критичных сообщений; это упрощает валидацию.
2. **Используйте `nodes()` и `value()`** для построчного извлечения данных, избегайте множественных вызовов `.query()`.
3. **Храните XML в `XML` типе**, а не в `NVARCHAR(MAX)`, чтобы использовать индексы XML.
4. **Создавайте первичные XML-индексы** для частого доступа; вторичные (PATH, VALUE) добавляйте только при необходимости.
5. **Отслеживайте размер сообщений**. Большие XML лучше обрабатывать пакетами и чистить промежуточные таблицы.

## 7. Тестирование и CI

1. **Модульное тестирование**. Используйте tSQLt или аналогичные фреймворки для автоматизации.
2. **Регрессионные тесты**. Храните набор образцов XML/JSON для воспроизведения ошибок.
3. **Infrastructure as Code**. Управляйте схемой через SSDT, Flyway или Liquibase.
4. **Code Review**. Настройте обязательный review для процедур с доступом к финансовым данным.
5. **Мониторинг**. Настройте алерты по времени выполнения и частоте ошибок в процедурах.

## 8. Антипаттерны

- Использование триггеров для массовых расчётов — лучше запускать пакетные задания.
- Вызов `EXEC('SELECT ...')` без параметров — открывает SQL-инъекции и делает планы нестабильными.
- Прерывание работы без `ROLLBACK` в CATCH-блоке — приводит к висящим транзакциям.
- Жёстко закодированные имена объектов и схем — используйте параметры и конфигурацию.

## 9. Контроль качества

- Проверяйте планы выполнения с помощью `sys.dm_exec_query_plan`.
- Используйте Extended Events вместо устаревшего SQL Trace.
- Для триггеров поддерживайте отдельную таблицу аудита с версиями изменений.

Следование данным рекомендациям повышает надёжность и управляемость серверной логики, снижает риски инцидентов и делает код понятнее для команды.
