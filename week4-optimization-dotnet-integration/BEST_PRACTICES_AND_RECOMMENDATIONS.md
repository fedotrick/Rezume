# Best Practices и рекомендации (Неделя 4)

## 1. Анализ и стабильность планов выполнения

1. **Фиксируйте исходный сценарий**. Перед оптимизацией сохраните запрос, входные параметры и статистику (`SET STATISTICS IO/TIME ON`, Query Store snapshot).
2. **Изучайте корень плана**. Высокая стоимость на операторах `Clustered Index Scan`, `Hash Match`, `Sort` сигнализирует о потенциальной оптимизации индекса или переписывании запроса.
3. **Следите за параметрическим сникером**. Для процедур с сильно плавающими параметрами используйте `OPTIMIZE FOR`, шаблоны recompile или план-гайды.
4. **Включите Query Store** в средах pre-prod/prod, чтобы отслеживать регрессии и закреплять стабильные планы (`FORCE_LAST_GOOD_PLAN`).
5. **Документируйте выводы**. Прикладывайте к тикетам планы в формате `.sqlplan` и ключевые метрики — это ускоряет командный анализ и ревью.

## 2. Индексация и структура данных

1. **Схема индекса = схема фильтрации**. Наборы фильтров должны начинаться с ведущих колонок BTREE-индекса; для диапазонов добавляйте включённые поля.
2. **Columnstore для фактов**. Сегментированная компрессия и batch mode ускоряют аналитические запросы, но требуют регулярного `REORGANIZE/REBUILD`.
3. **Партиционирование по дате**. Для таблиц на миллионы строк создавайте partition function + scheme; используйте sliding window и архивирование холодных сегментов.
4. **Дифференциация OLTP/OLAP**. Храните агрегаты в отдельных таблицах/материализованных представлениях, чтобы не перегружать транзакционную схему.
5. **Регулярное обслуживание**. Автоматизируйте обновление статистики, `DBCC CHECKDB`, defragmentation индексов, чтобы планы не деградировали.

## 3. Batch-обработка и BULK операции

1. **Размер батча**. Подбирайте batch 5k-50k строк в зависимости от логов и времени блокировок. Либо используйте `TOP (@batchSize)` + `DELETE/UPDATE` с `OUTPUT`.
2. **Минимизация журналирования**. Для BULK операций выбирайте `TABLOCK`, режим `BULK_LOGGED`, предварительно отключайте ненужные индексы.
3. **Параллелизм**. Контролируйте `MAXDOP`, включайте `Resource Governor`, если batch-обработка конкурирует с OLTP-нагрузкой.
4. **Stage-таблицы**. Загружайте данные во временные или staging-таблицы, проводите валидацию, затем перемещайте в боевые объекты транзакционно.
5. **Мониторинг очередей**. Используйте Service Broker, SQL Agent или Azure Data Factory для оркестрации и отслеживания выполнения ETL.

## 4. ADO.NET и Entity Framework Core

1. **Connection pooling**. Используйте `using` или `await using` для корректного возврата соединений в пул. Настройте `MinPoolSize/MaxPoolSize` под нагрузку.
2. **Настройки тайм-аутов**. Устанавливайте `CommandTimeout` (обычно 30–120 сек) и `Connect Timeout` (5–15 сек). Логируйте превышения и применяйте retry-политику.
3. **Параметризация**. Всегда передавайте параметры через `SqlParameter`/`DbParameter` — это предотвращает SQL-инъекции и помогает плану кешироваться.
4. **EF Core**. Включайте `EnableRetryOnFailure`, используйте `AsNoTracking()` для read-only запросов, проверяйте сгенерированные SQL через `ToQueryString()`.
5. **Наблюдаемость**. Добавляйте `DiagnosticListener`, Application Insights или OpenTelemetry для трассировки команд SQL из приложения.

## 5. Обработка ошибок и надёжность

1. **Транзакции**. Координируйте транзакции в .NET (`TransactionScope`, `BeginTransaction`) с тайм-аутами и гарантированным rollback на исключениях.
2. **Централизованное логирование**. Логируйте номера ошибок SQL Server, `RequestId`, входные параметры и длительность выполнения.
3. **Политика повторов**. Оснастите критичные операции (ETL, отчёты) retry-логикой с экспоненциальной задержкой, исключая неповторяемые ошибки (например, unique constraint).
4. **Идемпотентность ETL**. Используйте контрольные суммы, статусные таблицы и временные метки, чтобы повторный запуск не дублировал данные.
5. **Безопасность секретов**. Храните строки подключения в Azure Key Vault, AWS Secrets Manager или защищённых хранилищах, а не в конфигурациях в открытом виде.

## 6. Production Deployment

1. **Feature toggles**. Разворачивайте новые индексы/partitioning в режиме `ONLINE = ON` и включайте нагрузку поэтапно.
2. **Blue/Green или rolling**. Используйте схемы переключения (`ALTER SCHEMA ... TRANSFER`, swap partition) для минимизации простоя.
3. **Smoke-тесты**. После обновления запускайте набор диагностических запросов (latency, deadlock rate, актуальность статистики).
4. **План отката**. Подготовьте скрипты drop/rollback для индексов, partitioning и ETL-изменений перед релизом.
5. **Документация**. Фиксируйте вьюшки, индексы, процедуры и соответствующие версии приложений в runbook команды.

## 7. Мониторинг и алертинг

1. **Extended Events** / **Query Store** для отслеживания долгих запросов, wait statistics и деградации планов.
2. **Performance counters**: `Page Life Expectancy`, `Batch Requests/sec`, `Waits (CXPACKET, PAGEIOLATCH)`.
3. **Пороговые значения**. Настройте алерты на время выполнения ETL, блокировки > 30 сек, рост tempdb и журналов.
4. **Capacity planning**. Включите прогнозирование хранения для партиционированных таблиц и архивов.
5. **Регулярные ревью**. Раз в квартал проводите performance review: индексный аудит, профилирование приложений и обновление документации.

Следуя этим практикам, вы обеспечите устойчивую производительность, надёжность и предсказуемость решений, построенных на SQL Server и .NET.
